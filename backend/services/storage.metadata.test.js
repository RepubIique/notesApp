import { describe, it, before } from 'node:test';
import assert from 'node:assert';
import { createVoiceMessage } from './storage.js';

/**
 * Tests for voice message metadata consistency (Requirement 5.1)
 * Validates that voice messages include all standard message metadata
 */
describe('Voice Message Metadata Consistency (Requirement 5.1)', () => {
  describe('createVoiceMessage - metadata validation', () => {
    it('should validate sender is required', async () => {
      await assert.rejects(
        async () => {
          await createVoiceMessage(null, 'test-path.webm', 30);
        },
        {
          message: /Invalid sender/
        }
      );
    });

    it('should validate sender is A or B', async () => {
      await assert.rejects(
        async () => {
          await createVoiceMessage('C', 'test-path.webm', 30);
        },
        {
          message: /Invalid sender: must be A or B/
        }
      );
    });

    it('should validate audio path is required', async () => {
      await assert.rejects(
        async () => {
          await createVoiceMessage('A', null, 30);
        },
        {
          message: /Invalid audio path/
        }
      );
    });

    it('should validate audio path is a string', async () => {
      await assert.rejects(
        async () => {
          await createVoiceMessage('A', 123, 30);
        },
        {
          message: /Invalid audio path/
        }
      );
    });

    it('should validate audio duration is required', async () => {
      await assert.rejects(
        async () => {
          await createVoiceMessage('A', 'test-path.webm', null);
        },
        {
          message: /Invalid audio duration/
        }
      );
    });

    it('should validate audio duration is a number', async () => {
      await assert.rejects(
        async () => {
          await createVoiceMessage('A', 'test-path.webm', 'thirty');
        },
        {
          message: /Invalid audio duration/
        }
      );
    });

    it('should validate audio duration is positive', async () => {
      await assert.rejects(
        async () => {
          await createVoiceMessage('A', 'test-path.webm', -5);
        },
        {
          message: /Invalid audio duration/
        }
      );
    });

    it('should validate audio duration is not zero', async () => {
      await assert.rejects(
        async () => {
          await createVoiceMessage('A', 'test-path.webm', 0);
        },
        {
          message: /Invalid audio duration/
        }
      );
    });
  });

  describe('createVoiceMessage - metadata consistency', () => {
    it('should document required metadata fields', () => {
      // Voice messages must include the same metadata as other message types
      const requiredMetadata = {
        id: 'UUID - generated by database',
        sender: 'A or B - identifies message sender',
        type: 'voice - message type',
        created_at: 'ISO timestamp - when message was created',
        deleted: 'boolean - soft delete flag',
        // Voice-specific fields
        audio_path: 'string - storage path to audio file',
        audio_duration: 'number - duration in seconds'
      };

      // Verify all required fields are documented
      assert.ok(requiredMetadata.id);
      assert.ok(requiredMetadata.sender);
      assert.ok(requiredMetadata.type);
      assert.ok(requiredMetadata.created_at);
      assert.ok(requiredMetadata.deleted);
      assert.ok(requiredMetadata.audio_path);
      assert.ok(requiredMetadata.audio_duration);
    });

    it('should document optional status metadata fields', () => {
      // Voice messages can include optional status tracking fields
      const optionalMetadata = {
        delivered_at: 'ISO timestamp - when message was delivered',
        read_at: 'ISO timestamp - when message was read',
        read_by: 'A or B - who read the message'
      };

      // These fields are managed by the message system, not voice-specific code
      assert.ok(optionalMetadata.delivered_at);
      assert.ok(optionalMetadata.read_at);
      assert.ok(optionalMetadata.read_by);
    });
  });
});
